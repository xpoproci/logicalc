//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.12.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from Logic.g4 by ANTLR 4.12.0

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.12.0")]
[System.CLSCompliant(false)]
public partial class LogicParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		WHITESPACE=1, COMMENT=2, OPEN_PAREN=3, CLOSE_PAREN=4, COMMA=5, SEMICOLON=6, 
		AND=7, OR=8, IMP=9, BICOND=10, NEG=11, XOR=12, IDENTITY=13, ATOM=14, CONSTANT=15, 
		VARIABLE=16, EXISTENTIAL=17, UNIVERSAL=18, THEREFORE=19, SEMANTIC_ENTAILMENT=20;
	public const int
		RULE_program = 0, RULE_atom = 1, RULE_propositionalWff = 2, RULE_propWff = 3, 
		RULE_propNegRule = 4, RULE_propAndRule = 5, RULE_propOrRule = 6, RULE_propImpRule = 7, 
		RULE_propBicondRule = 8, RULE_propExclusiveOrRule = 9, RULE_constant = 10, 
		RULE_variable = 11, RULE_universal = 12, RULE_existential = 13, RULE_predicate = 14, 
		RULE_predicateWff = 15, RULE_predWff = 16, RULE_predQuantifier = 17, RULE_predNegRule = 18, 
		RULE_predAndRule = 19, RULE_predOrRule = 20, RULE_predImpRule = 21, RULE_predBicondRule = 22, 
		RULE_predExclusiveOrRule = 23, RULE_predIdentityRule = 24, RULE_predPremise = 25, 
		RULE_predConclusion = 26, RULE_predProof = 27, RULE_propPremise = 28, 
		RULE_propConclusion = 29, RULE_propProof = 30, RULE_predSemanticEntailment = 31, 
		RULE_propSemanticEntailment = 32;
	public static readonly string[] ruleNames = {
		"program", "atom", "propositionalWff", "propWff", "propNegRule", "propAndRule", 
		"propOrRule", "propImpRule", "propBicondRule", "propExclusiveOrRule", 
		"constant", "variable", "universal", "existential", "predicate", "predicateWff", 
		"predWff", "predQuantifier", "predNegRule", "predAndRule", "predOrRule", 
		"predImpRule", "predBicondRule", "predExclusiveOrRule", "predIdentityRule", 
		"predPremise", "predConclusion", "predProof", "propPremise", "propConclusion", 
		"propProof", "predSemanticEntailment", "propSemanticEntailment"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, "'('", "')'", "','", "';'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "WHITESPACE", "COMMENT", "OPEN_PAREN", "CLOSE_PAREN", "COMMA", "SEMICOLON", 
		"AND", "OR", "IMP", "BICOND", "NEG", "XOR", "IDENTITY", "ATOM", "CONSTANT", 
		"VARIABLE", "EXISTENTIAL", "UNIVERSAL", "THEREFORE", "SEMANTIC_ENTAILMENT"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "Logic.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static LogicParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public LogicParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public LogicParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ProgramContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PredProofContext predProof() {
			return GetRuleContext<PredProofContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(LogicParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropProofContext propProof() {
			return GetRuleContext<PropProofContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredSemanticEntailmentContext predSemanticEntailment() {
			return GetRuleContext<PredSemanticEntailmentContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropSemanticEntailmentContext propSemanticEntailment() {
			return GetRuleContext<PropSemanticEntailmentContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropositionalWffContext[] propositionalWff() {
			return GetRuleContexts<PropositionalWffContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropositionalWffContext propositionalWff(int i) {
			return GetRuleContext<PropositionalWffContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(LogicParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PredicateWffContext[] predicateWff() {
			return GetRuleContexts<PredicateWffContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredicateWffContext predicateWff(int i) {
			return GetRuleContext<PredicateWffContext>(i);
		}
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterProgram(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitProgram(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(Context, State);
		EnterRule(_localctx, 0, RULE_program);
		try {
			State = 94;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,0,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 66;
				predProof();
				State = 67;
				Match(Eof);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				{
				State = 69;
				propProof();
				State = 70;
				Match(Eof);
				}
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				{
				State = 72;
				predSemanticEntailment();
				State = 73;
				Match(Eof);
				}
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				{
				State = 75;
				propSemanticEntailment();
				State = 76;
				Match(Eof);
				}
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				{
				State = 78;
				propositionalWff();
				State = 79;
				Match(COMMA);
				State = 80;
				propositionalWff();
				State = 81;
				Match(Eof);
				}
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				{
				State = 83;
				predicateWff();
				State = 84;
				Match(COMMA);
				State = 85;
				predicateWff();
				State = 86;
				Match(Eof);
				}
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				{
				State = 88;
				propositionalWff();
				State = 89;
				Match(Eof);
				}
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				{
				State = 91;
				predicateWff();
				State = 92;
				Match(Eof);
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AtomContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ATOM() { return GetToken(LogicParser.ATOM, 0); }
		public AtomContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_atom; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterAtom(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitAtom(this);
		}
	}

	[RuleVersion(0)]
	public AtomContext atom() {
		AtomContext _localctx = new AtomContext(Context, State);
		EnterRule(_localctx, 2, RULE_atom);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 96;
			Match(ATOM);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropositionalWffContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PropWffContext propWff() {
			return GetRuleContext<PropWffContext>(0);
		}
		public PropositionalWffContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propositionalWff; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPropositionalWff(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPropositionalWff(this);
		}
	}

	[RuleVersion(0)]
	public PropositionalWffContext propositionalWff() {
		PropositionalWffContext _localctx = new PropositionalWffContext(Context, State);
		EnterRule(_localctx, 4, RULE_propositionalWff);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 98;
			propWff();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropWffContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AtomContext atom() {
			return GetRuleContext<AtomContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropNegRuleContext propNegRule() {
			return GetRuleContext<PropNegRuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropAndRuleContext propAndRule() {
			return GetRuleContext<PropAndRuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropOrRuleContext propOrRule() {
			return GetRuleContext<PropOrRuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropImpRuleContext propImpRule() {
			return GetRuleContext<PropImpRuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropBicondRuleContext propBicondRule() {
			return GetRuleContext<PropBicondRuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropExclusiveOrRuleContext propExclusiveOrRule() {
			return GetRuleContext<PropExclusiveOrRuleContext>(0);
		}
		public PropWffContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propWff; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPropWff(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPropWff(this);
		}
	}

	[RuleVersion(0)]
	public PropWffContext propWff() {
		PropWffContext _localctx = new PropWffContext(Context, State);
		EnterRule(_localctx, 6, RULE_propWff);
		try {
			State = 107;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,1,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 100;
				atom();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 101;
				propNegRule();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 102;
				propAndRule();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 103;
				propOrRule();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 104;
				propImpRule();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 105;
				propBicondRule();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 106;
				propExclusiveOrRule();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropNegRuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEG() { return GetToken(LogicParser.NEG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropWffContext propWff() {
			return GetRuleContext<PropWffContext>(0);
		}
		public PropNegRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propNegRule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPropNegRule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPropNegRule(this);
		}
	}

	[RuleVersion(0)]
	public PropNegRuleContext propNegRule() {
		PropNegRuleContext _localctx = new PropNegRuleContext(Context, State);
		EnterRule(_localctx, 8, RULE_propNegRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 109;
			Match(NEG);
			State = 110;
			propWff();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropAndRuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN_PAREN() { return GetToken(LogicParser.OPEN_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropWffContext[] propWff() {
			return GetRuleContexts<PropWffContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropWffContext propWff(int i) {
			return GetRuleContext<PropWffContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(LogicParser.AND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE_PAREN() { return GetToken(LogicParser.CLOSE_PAREN, 0); }
		public PropAndRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propAndRule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPropAndRule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPropAndRule(this);
		}
	}

	[RuleVersion(0)]
	public PropAndRuleContext propAndRule() {
		PropAndRuleContext _localctx = new PropAndRuleContext(Context, State);
		EnterRule(_localctx, 10, RULE_propAndRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 112;
			Match(OPEN_PAREN);
			State = 113;
			propWff();
			State = 114;
			Match(AND);
			State = 115;
			propWff();
			State = 116;
			Match(CLOSE_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropOrRuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN_PAREN() { return GetToken(LogicParser.OPEN_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropWffContext[] propWff() {
			return GetRuleContexts<PropWffContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropWffContext propWff(int i) {
			return GetRuleContext<PropWffContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(LogicParser.OR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE_PAREN() { return GetToken(LogicParser.CLOSE_PAREN, 0); }
		public PropOrRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propOrRule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPropOrRule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPropOrRule(this);
		}
	}

	[RuleVersion(0)]
	public PropOrRuleContext propOrRule() {
		PropOrRuleContext _localctx = new PropOrRuleContext(Context, State);
		EnterRule(_localctx, 12, RULE_propOrRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 118;
			Match(OPEN_PAREN);
			State = 119;
			propWff();
			State = 120;
			Match(OR);
			State = 121;
			propWff();
			State = 122;
			Match(CLOSE_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropImpRuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN_PAREN() { return GetToken(LogicParser.OPEN_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropWffContext[] propWff() {
			return GetRuleContexts<PropWffContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropWffContext propWff(int i) {
			return GetRuleContext<PropWffContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMP() { return GetToken(LogicParser.IMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE_PAREN() { return GetToken(LogicParser.CLOSE_PAREN, 0); }
		public PropImpRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propImpRule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPropImpRule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPropImpRule(this);
		}
	}

	[RuleVersion(0)]
	public PropImpRuleContext propImpRule() {
		PropImpRuleContext _localctx = new PropImpRuleContext(Context, State);
		EnterRule(_localctx, 14, RULE_propImpRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 124;
			Match(OPEN_PAREN);
			State = 125;
			propWff();
			State = 126;
			Match(IMP);
			State = 127;
			propWff();
			State = 128;
			Match(CLOSE_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropBicondRuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN_PAREN() { return GetToken(LogicParser.OPEN_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropWffContext[] propWff() {
			return GetRuleContexts<PropWffContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropWffContext propWff(int i) {
			return GetRuleContext<PropWffContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BICOND() { return GetToken(LogicParser.BICOND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE_PAREN() { return GetToken(LogicParser.CLOSE_PAREN, 0); }
		public PropBicondRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propBicondRule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPropBicondRule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPropBicondRule(this);
		}
	}

	[RuleVersion(0)]
	public PropBicondRuleContext propBicondRule() {
		PropBicondRuleContext _localctx = new PropBicondRuleContext(Context, State);
		EnterRule(_localctx, 16, RULE_propBicondRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 130;
			Match(OPEN_PAREN);
			State = 131;
			propWff();
			State = 132;
			Match(BICOND);
			State = 133;
			propWff();
			State = 134;
			Match(CLOSE_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropExclusiveOrRuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN_PAREN() { return GetToken(LogicParser.OPEN_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropWffContext[] propWff() {
			return GetRuleContexts<PropWffContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropWffContext propWff(int i) {
			return GetRuleContext<PropWffContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XOR() { return GetToken(LogicParser.XOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE_PAREN() { return GetToken(LogicParser.CLOSE_PAREN, 0); }
		public PropExclusiveOrRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propExclusiveOrRule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPropExclusiveOrRule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPropExclusiveOrRule(this);
		}
	}

	[RuleVersion(0)]
	public PropExclusiveOrRuleContext propExclusiveOrRule() {
		PropExclusiveOrRuleContext _localctx = new PropExclusiveOrRuleContext(Context, State);
		EnterRule(_localctx, 18, RULE_propExclusiveOrRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 136;
			Match(OPEN_PAREN);
			State = 137;
			propWff();
			State = 138;
			Match(XOR);
			State = 139;
			propWff();
			State = 140;
			Match(CLOSE_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstantContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTANT() { return GetToken(LogicParser.CONSTANT, 0); }
		public ConstantContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constant; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterConstant(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitConstant(this);
		}
	}

	[RuleVersion(0)]
	public ConstantContext constant() {
		ConstantContext _localctx = new ConstantContext(Context, State);
		EnterRule(_localctx, 20, RULE_constant);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 142;
			Match(CONSTANT);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARIABLE() { return GetToken(LogicParser.VARIABLE, 0); }
		public VariableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variable; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterVariable(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitVariable(this);
		}
	}

	[RuleVersion(0)]
	public VariableContext variable() {
		VariableContext _localctx = new VariableContext(Context, State);
		EnterRule(_localctx, 22, RULE_variable);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 144;
			Match(VARIABLE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UniversalContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN_PAREN() { return GetToken(LogicParser.OPEN_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIVERSAL() { return GetToken(LogicParser.UNIVERSAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE_PAREN() { return GetToken(LogicParser.CLOSE_PAREN, 0); }
		public UniversalContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_universal; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterUniversal(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitUniversal(this);
		}
	}

	[RuleVersion(0)]
	public UniversalContext universal() {
		UniversalContext _localctx = new UniversalContext(Context, State);
		EnterRule(_localctx, 24, RULE_universal);
		try {
			State = 155;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				{
				State = 146;
				Match(OPEN_PAREN);
				State = 147;
				Match(UNIVERSAL);
				State = 148;
				variable();
				State = 149;
				Match(CLOSE_PAREN);
				}
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 151;
				Match(OPEN_PAREN);
				State = 152;
				variable();
				State = 153;
				Match(CLOSE_PAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExistentialContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN_PAREN() { return GetToken(LogicParser.OPEN_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTENTIAL() { return GetToken(LogicParser.EXISTENTIAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE_PAREN() { return GetToken(LogicParser.CLOSE_PAREN, 0); }
		public ExistentialContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_existential; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterExistential(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitExistential(this);
		}
	}

	[RuleVersion(0)]
	public ExistentialContext existential() {
		ExistentialContext _localctx = new ExistentialContext(Context, State);
		EnterRule(_localctx, 26, RULE_existential);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 157;
			Match(OPEN_PAREN);
			State = 158;
			Match(EXISTENTIAL);
			State = 159;
			variable();
			State = 160;
			Match(CLOSE_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredicateContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AtomContext atom() {
			return GetRuleContext<AtomContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN_PAREN() { return GetToken(LogicParser.OPEN_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE_PAREN() { return GetToken(LogicParser.CLOSE_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstantContext[] constant() {
			return GetRuleContexts<ConstantContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstantContext constant(int i) {
			return GetRuleContext<ConstantContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext[] variable() {
			return GetRuleContexts<VariableContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable(int i) {
			return GetRuleContext<VariableContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(LogicParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(LogicParser.COMMA, i);
		}
		public PredicateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predicate; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPredicate(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPredicate(this);
		}
	}

	[RuleVersion(0)]
	public PredicateContext predicate() {
		PredicateContext _localctx = new PredicateContext(Context, State);
		EnterRule(_localctx, 28, RULE_predicate);
		int _la;
		try {
			int _alt;
			State = 191;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,9,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 162;
				atom();
				State = 163;
				Match(OPEN_PAREN);
				State = 178;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					State = 178;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case CONSTANT:
						{
						State = 164;
						constant();
						State = 168;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						while (_la==COMMA) {
							{
							{
							State = 165;
							Match(COMMA);
							}
							}
							State = 170;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
						}
						}
						break;
					case VARIABLE:
						{
						State = 171;
						variable();
						State = 175;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						while (_la==COMMA) {
							{
							{
							State = 172;
							Match(COMMA);
							}
							}
							State = 177;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					State = 180;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==CONSTANT || _la==VARIABLE );
				State = 182;
				Match(CLOSE_PAREN);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 184;
				atom();
				State = 187;
				ErrorHandler.Sync(this);
				_alt = 1;
				do {
					switch (_alt) {
					case 1:
						{
						State = 187;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case CONSTANT:
							{
							State = 185;
							constant();
							}
							break;
						case VARIABLE:
							{
							State = 186;
							variable();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					State = 189;
					ErrorHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(TokenStream,8,Context);
				} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredicateWffContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PredWffContext predWff() {
			return GetRuleContext<PredWffContext>(0);
		}
		public PredicateWffContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predicateWff; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPredicateWff(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPredicateWff(this);
		}
	}

	[RuleVersion(0)]
	public PredicateWffContext predicateWff() {
		PredicateWffContext _localctx = new PredicateWffContext(Context, State);
		EnterRule(_localctx, 30, RULE_predicateWff);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 193;
			predWff();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredWffContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PredicateContext predicate() {
			return GetRuleContext<PredicateContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredNegRuleContext predNegRule() {
			return GetRuleContext<PredNegRuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredQuantifierContext predQuantifier() {
			return GetRuleContext<PredQuantifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredAndRuleContext predAndRule() {
			return GetRuleContext<PredAndRuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredOrRuleContext predOrRule() {
			return GetRuleContext<PredOrRuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredImpRuleContext predImpRule() {
			return GetRuleContext<PredImpRuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredBicondRuleContext predBicondRule() {
			return GetRuleContext<PredBicondRuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredExclusiveOrRuleContext predExclusiveOrRule() {
			return GetRuleContext<PredExclusiveOrRuleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredIdentityRuleContext predIdentityRule() {
			return GetRuleContext<PredIdentityRuleContext>(0);
		}
		public PredWffContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predWff; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPredWff(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPredWff(this);
		}
	}

	[RuleVersion(0)]
	public PredWffContext predWff() {
		PredWffContext _localctx = new PredWffContext(Context, State);
		EnterRule(_localctx, 32, RULE_predWff);
		try {
			State = 204;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,10,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 195;
				predicate();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 196;
				predNegRule();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 197;
				predQuantifier();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 198;
				predAndRule();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 199;
				predOrRule();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 200;
				predImpRule();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 201;
				predBicondRule();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 202;
				predExclusiveOrRule();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 203;
				predIdentityRule();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredQuantifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PredWffContext predWff() {
			return GetRuleContext<PredWffContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExistentialContext existential() {
			return GetRuleContext<ExistentialContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UniversalContext universal() {
			return GetRuleContext<UniversalContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEG() { return GetToken(LogicParser.NEG, 0); }
		public PredQuantifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predQuantifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPredQuantifier(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPredQuantifier(this);
		}
	}

	[RuleVersion(0)]
	public PredQuantifierContext predQuantifier() {
		PredQuantifierContext _localctx = new PredQuantifierContext(Context, State);
		EnterRule(_localctx, 34, RULE_predQuantifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 207;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NEG) {
				{
				State = 206;
				Match(NEG);
				}
			}

			State = 211;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
			case 1:
				{
				State = 209;
				existential();
				}
				break;
			case 2:
				{
				State = 210;
				universal();
				}
				break;
			}
			State = 213;
			predWff();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredNegRuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEG() { return GetToken(LogicParser.NEG, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PredWffContext predWff() {
			return GetRuleContext<PredWffContext>(0);
		}
		public PredNegRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predNegRule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPredNegRule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPredNegRule(this);
		}
	}

	[RuleVersion(0)]
	public PredNegRuleContext predNegRule() {
		PredNegRuleContext _localctx = new PredNegRuleContext(Context, State);
		EnterRule(_localctx, 36, RULE_predNegRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 215;
			Match(NEG);
			State = 216;
			predWff();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredAndRuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN_PAREN() { return GetToken(LogicParser.OPEN_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PredWffContext[] predWff() {
			return GetRuleContexts<PredWffContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredWffContext predWff(int i) {
			return GetRuleContext<PredWffContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(LogicParser.AND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE_PAREN() { return GetToken(LogicParser.CLOSE_PAREN, 0); }
		public PredAndRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predAndRule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPredAndRule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPredAndRule(this);
		}
	}

	[RuleVersion(0)]
	public PredAndRuleContext predAndRule() {
		PredAndRuleContext _localctx = new PredAndRuleContext(Context, State);
		EnterRule(_localctx, 38, RULE_predAndRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 218;
			Match(OPEN_PAREN);
			State = 219;
			predWff();
			State = 220;
			Match(AND);
			State = 221;
			predWff();
			State = 222;
			Match(CLOSE_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredOrRuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN_PAREN() { return GetToken(LogicParser.OPEN_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PredWffContext[] predWff() {
			return GetRuleContexts<PredWffContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredWffContext predWff(int i) {
			return GetRuleContext<PredWffContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(LogicParser.OR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE_PAREN() { return GetToken(LogicParser.CLOSE_PAREN, 0); }
		public PredOrRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predOrRule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPredOrRule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPredOrRule(this);
		}
	}

	[RuleVersion(0)]
	public PredOrRuleContext predOrRule() {
		PredOrRuleContext _localctx = new PredOrRuleContext(Context, State);
		EnterRule(_localctx, 40, RULE_predOrRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 224;
			Match(OPEN_PAREN);
			State = 225;
			predWff();
			State = 226;
			Match(OR);
			State = 227;
			predWff();
			State = 228;
			Match(CLOSE_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredImpRuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN_PAREN() { return GetToken(LogicParser.OPEN_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PredWffContext[] predWff() {
			return GetRuleContexts<PredWffContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredWffContext predWff(int i) {
			return GetRuleContext<PredWffContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMP() { return GetToken(LogicParser.IMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE_PAREN() { return GetToken(LogicParser.CLOSE_PAREN, 0); }
		public PredImpRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predImpRule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPredImpRule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPredImpRule(this);
		}
	}

	[RuleVersion(0)]
	public PredImpRuleContext predImpRule() {
		PredImpRuleContext _localctx = new PredImpRuleContext(Context, State);
		EnterRule(_localctx, 42, RULE_predImpRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 230;
			Match(OPEN_PAREN);
			State = 231;
			predWff();
			State = 232;
			Match(IMP);
			State = 233;
			predWff();
			State = 234;
			Match(CLOSE_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredBicondRuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN_PAREN() { return GetToken(LogicParser.OPEN_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PredWffContext[] predWff() {
			return GetRuleContexts<PredWffContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredWffContext predWff(int i) {
			return GetRuleContext<PredWffContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BICOND() { return GetToken(LogicParser.BICOND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE_PAREN() { return GetToken(LogicParser.CLOSE_PAREN, 0); }
		public PredBicondRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predBicondRule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPredBicondRule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPredBicondRule(this);
		}
	}

	[RuleVersion(0)]
	public PredBicondRuleContext predBicondRule() {
		PredBicondRuleContext _localctx = new PredBicondRuleContext(Context, State);
		EnterRule(_localctx, 44, RULE_predBicondRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 236;
			Match(OPEN_PAREN);
			State = 237;
			predWff();
			State = 238;
			Match(BICOND);
			State = 239;
			predWff();
			State = 240;
			Match(CLOSE_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredExclusiveOrRuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPEN_PAREN() { return GetToken(LogicParser.OPEN_PAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PredWffContext[] predWff() {
			return GetRuleContexts<PredWffContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredWffContext predWff(int i) {
			return GetRuleContext<PredWffContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XOR() { return GetToken(LogicParser.XOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CLOSE_PAREN() { return GetToken(LogicParser.CLOSE_PAREN, 0); }
		public PredExclusiveOrRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predExclusiveOrRule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPredExclusiveOrRule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPredExclusiveOrRule(this);
		}
	}

	[RuleVersion(0)]
	public PredExclusiveOrRuleContext predExclusiveOrRule() {
		PredExclusiveOrRuleContext _localctx = new PredExclusiveOrRuleContext(Context, State);
		EnterRule(_localctx, 46, RULE_predExclusiveOrRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 242;
			Match(OPEN_PAREN);
			State = 243;
			predWff();
			State = 244;
			Match(XOR);
			State = 245;
			predWff();
			State = 246;
			Match(CLOSE_PAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredIdentityRuleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTITY() { return GetToken(LogicParser.IDENTITY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstantContext[] constant() {
			return GetRuleContexts<ConstantContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstantContext constant(int i) {
			return GetRuleContext<ConstantContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext[] variable() {
			return GetRuleContexts<VariableContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable(int i) {
			return GetRuleContext<VariableContext>(i);
		}
		public PredIdentityRuleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predIdentityRule; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPredIdentityRule(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPredIdentityRule(this);
		}
	}

	[RuleVersion(0)]
	public PredIdentityRuleContext predIdentityRule() {
		PredIdentityRuleContext _localctx = new PredIdentityRuleContext(Context, State);
		EnterRule(_localctx, 48, RULE_predIdentityRule);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 250;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CONSTANT:
				{
				State = 248;
				constant();
				}
				break;
			case VARIABLE:
				{
				State = 249;
				variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 252;
			Match(IDENTITY);
			State = 255;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CONSTANT:
				{
				State = 253;
				constant();
				}
				break;
			case VARIABLE:
				{
				State = 254;
				variable();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredPremiseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PredicateWffContext predicateWff() {
			return GetRuleContext<PredicateWffContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(LogicParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(LogicParser.SEMICOLON, 0); }
		public PredPremiseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predPremise; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPredPremise(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPredPremise(this);
		}
	}

	[RuleVersion(0)]
	public PredPremiseContext predPremise() {
		PredPremiseContext _localctx = new PredPremiseContext(Context, State);
		EnterRule(_localctx, 50, RULE_predPremise);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 261;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				{
				{
				State = 257;
				predicateWff();
				State = 258;
				_la = TokenStream.LA(1);
				if ( !(_la==COMMA || _la==SEMICOLON) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				}
				break;
			case 2:
				{
				State = 260;
				predicateWff();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredConclusionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PredicateWffContext predicateWff() {
			return GetRuleContext<PredicateWffContext>(0);
		}
		public PredConclusionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predConclusion; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPredConclusion(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPredConclusion(this);
		}
	}

	[RuleVersion(0)]
	public PredConclusionContext predConclusion() {
		PredConclusionContext _localctx = new PredConclusionContext(Context, State);
		EnterRule(_localctx, 52, RULE_predConclusion);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 263;
			predicateWff();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredProofContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEREFORE() { return GetToken(LogicParser.THEREFORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PredConclusionContext predConclusion() {
			return GetRuleContext<PredConclusionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredPremiseContext[] predPremise() {
			return GetRuleContexts<PredPremiseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredPremiseContext predPremise(int i) {
			return GetRuleContext<PredPremiseContext>(i);
		}
		public PredProofContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predProof; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPredProof(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPredProof(this);
		}
	}

	[RuleVersion(0)]
	public PredProofContext predProof() {
		PredProofContext _localctx = new PredProofContext(Context, State);
		EnterRule(_localctx, 54, RULE_predProof);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 266;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 265;
				predPremise();
				}
				}
				State = 268;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & 116744L) != 0) );
			State = 270;
			Match(THEREFORE);
			State = 271;
			predConclusion();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropPremiseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PropositionalWffContext propositionalWff() {
			return GetRuleContext<PropositionalWffContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(LogicParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON() { return GetToken(LogicParser.SEMICOLON, 0); }
		public PropPremiseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propPremise; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPropPremise(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPropPremise(this);
		}
	}

	[RuleVersion(0)]
	public PropPremiseContext propPremise() {
		PropPremiseContext _localctx = new PropPremiseContext(Context, State);
		EnterRule(_localctx, 56, RULE_propPremise);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 277;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				{
				{
				State = 273;
				propositionalWff();
				State = 274;
				_la = TokenStream.LA(1);
				if ( !(_la==COMMA || _la==SEMICOLON) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				}
				break;
			case 2:
				{
				State = 276;
				propositionalWff();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropConclusionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PropositionalWffContext propositionalWff() {
			return GetRuleContext<PropositionalWffContext>(0);
		}
		public PropConclusionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propConclusion; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPropConclusion(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPropConclusion(this);
		}
	}

	[RuleVersion(0)]
	public PropConclusionContext propConclusion() {
		PropConclusionContext _localctx = new PropConclusionContext(Context, State);
		EnterRule(_localctx, 58, RULE_propConclusion);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 279;
			propositionalWff();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropProofContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEREFORE() { return GetToken(LogicParser.THEREFORE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropConclusionContext propConclusion() {
			return GetRuleContext<PropConclusionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropPremiseContext[] propPremise() {
			return GetRuleContexts<PropPremiseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropPremiseContext propPremise(int i) {
			return GetRuleContext<PropPremiseContext>(i);
		}
		public PropProofContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propProof; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPropProof(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPropProof(this);
		}
	}

	[RuleVersion(0)]
	public PropProofContext propProof() {
		PropProofContext _localctx = new PropProofContext(Context, State);
		EnterRule(_localctx, 60, RULE_propProof);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 282;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 281;
				propPremise();
				}
				}
				State = 284;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & 18440L) != 0) );
			State = 286;
			Match(THEREFORE);
			State = 287;
			propConclusion();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PredSemanticEntailmentContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMANTIC_ENTAILMENT() { return GetToken(LogicParser.SEMANTIC_ENTAILMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PredicateWffContext predicateWff() {
			return GetRuleContext<PredicateWffContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredPremiseContext[] predPremise() {
			return GetRuleContexts<PredPremiseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PredPremiseContext predPremise(int i) {
			return GetRuleContext<PredPremiseContext>(i);
		}
		public PredSemanticEntailmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_predSemanticEntailment; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPredSemanticEntailment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPredSemanticEntailment(this);
		}
	}

	[RuleVersion(0)]
	public PredSemanticEntailmentContext predSemanticEntailment() {
		PredSemanticEntailmentContext _localctx = new PredSemanticEntailmentContext(Context, State);
		EnterRule(_localctx, 62, RULE_predSemanticEntailment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 290;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 289;
				predPremise();
				}
				}
				State = 292;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & 116744L) != 0) );
			State = 294;
			Match(SEMANTIC_ENTAILMENT);
			State = 295;
			predicateWff();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropSemanticEntailmentContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMANTIC_ENTAILMENT() { return GetToken(LogicParser.SEMANTIC_ENTAILMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropositionalWffContext propositionalWff() {
			return GetRuleContext<PropositionalWffContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropPremiseContext[] propPremise() {
			return GetRuleContexts<PropPremiseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropPremiseContext propPremise(int i) {
			return GetRuleContext<PropPremiseContext>(i);
		}
		public PropSemanticEntailmentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propSemanticEntailment; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.EnterPropSemanticEntailment(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ILogicListener typedListener = listener as ILogicListener;
			if (typedListener != null) typedListener.ExitPropSemanticEntailment(this);
		}
	}

	[RuleVersion(0)]
	public PropSemanticEntailmentContext propSemanticEntailment() {
		PropSemanticEntailmentContext _localctx = new PropSemanticEntailmentContext(Context, State);
		EnterRule(_localctx, 64, RULE_propSemanticEntailment);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 298;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 297;
				propPremise();
				}
				}
				State = 300;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( (((_la) & ~0x3f) == 0 && ((1L << _la) & 18440L) != 0) );
			State = 302;
			Match(SEMANTIC_ENTAILMENT);
			State = 303;
			propositionalWff();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,20,306,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,7,
		7,7,2,8,7,8,2,9,7,9,2,10,7,10,2,11,7,11,2,12,7,12,2,13,7,13,2,14,7,14,
		2,15,7,15,2,16,7,16,2,17,7,17,2,18,7,18,2,19,7,19,2,20,7,20,2,21,7,21,
		2,22,7,22,2,23,7,23,2,24,7,24,2,25,7,25,2,26,7,26,2,27,7,27,2,28,7,28,
		2,29,7,29,2,30,7,30,2,31,7,31,2,32,7,32,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,
		0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,
		1,0,1,0,1,0,3,0,95,8,0,1,1,1,1,1,2,1,2,1,3,1,3,1,3,1,3,1,3,1,3,1,3,3,3,
		108,8,3,1,4,1,4,1,4,1,5,1,5,1,5,1,5,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,6,1,
		7,1,7,1,7,1,7,1,7,1,7,1,8,1,8,1,8,1,8,1,8,1,8,1,9,1,9,1,9,1,9,1,9,1,9,
		1,10,1,10,1,11,1,11,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,1,12,3,12,
		156,8,12,1,13,1,13,1,13,1,13,1,13,1,14,1,14,1,14,1,14,5,14,167,8,14,10,
		14,12,14,170,9,14,1,14,1,14,5,14,174,8,14,10,14,12,14,177,9,14,4,14,179,
		8,14,11,14,12,14,180,1,14,1,14,1,14,1,14,1,14,4,14,188,8,14,11,14,12,14,
		189,3,14,192,8,14,1,15,1,15,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,16,1,
		16,3,16,205,8,16,1,17,3,17,208,8,17,1,17,1,17,3,17,212,8,17,1,17,1,17,
		1,18,1,18,1,18,1,19,1,19,1,19,1,19,1,19,1,19,1,20,1,20,1,20,1,20,1,20,
		1,20,1,21,1,21,1,21,1,21,1,21,1,21,1,22,1,22,1,22,1,22,1,22,1,22,1,23,
		1,23,1,23,1,23,1,23,1,23,1,24,1,24,3,24,251,8,24,1,24,1,24,1,24,3,24,256,
		8,24,1,25,1,25,1,25,1,25,3,25,262,8,25,1,26,1,26,1,27,4,27,267,8,27,11,
		27,12,27,268,1,27,1,27,1,27,1,28,1,28,1,28,1,28,3,28,278,8,28,1,29,1,29,
		1,30,4,30,283,8,30,11,30,12,30,284,1,30,1,30,1,30,1,31,4,31,291,8,31,11,
		31,12,31,292,1,31,1,31,1,31,1,32,4,32,299,8,32,11,32,12,32,300,1,32,1,
		32,1,32,1,32,0,0,33,0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,
		38,40,42,44,46,48,50,52,54,56,58,60,62,64,0,1,1,0,5,6,311,0,94,1,0,0,0,
		2,96,1,0,0,0,4,98,1,0,0,0,6,107,1,0,0,0,8,109,1,0,0,0,10,112,1,0,0,0,12,
		118,1,0,0,0,14,124,1,0,0,0,16,130,1,0,0,0,18,136,1,0,0,0,20,142,1,0,0,
		0,22,144,1,0,0,0,24,155,1,0,0,0,26,157,1,0,0,0,28,191,1,0,0,0,30,193,1,
		0,0,0,32,204,1,0,0,0,34,207,1,0,0,0,36,215,1,0,0,0,38,218,1,0,0,0,40,224,
		1,0,0,0,42,230,1,0,0,0,44,236,1,0,0,0,46,242,1,0,0,0,48,250,1,0,0,0,50,
		261,1,0,0,0,52,263,1,0,0,0,54,266,1,0,0,0,56,277,1,0,0,0,58,279,1,0,0,
		0,60,282,1,0,0,0,62,290,1,0,0,0,64,298,1,0,0,0,66,67,3,54,27,0,67,68,5,
		0,0,1,68,95,1,0,0,0,69,70,3,60,30,0,70,71,5,0,0,1,71,95,1,0,0,0,72,73,
		3,62,31,0,73,74,5,0,0,1,74,95,1,0,0,0,75,76,3,64,32,0,76,77,5,0,0,1,77,
		95,1,0,0,0,78,79,3,4,2,0,79,80,5,5,0,0,80,81,3,4,2,0,81,82,5,0,0,1,82,
		95,1,0,0,0,83,84,3,30,15,0,84,85,5,5,0,0,85,86,3,30,15,0,86,87,5,0,0,1,
		87,95,1,0,0,0,88,89,3,4,2,0,89,90,5,0,0,1,90,95,1,0,0,0,91,92,3,30,15,
		0,92,93,5,0,0,1,93,95,1,0,0,0,94,66,1,0,0,0,94,69,1,0,0,0,94,72,1,0,0,
		0,94,75,1,0,0,0,94,78,1,0,0,0,94,83,1,0,0,0,94,88,1,0,0,0,94,91,1,0,0,
		0,95,1,1,0,0,0,96,97,5,14,0,0,97,3,1,0,0,0,98,99,3,6,3,0,99,5,1,0,0,0,
		100,108,3,2,1,0,101,108,3,8,4,0,102,108,3,10,5,0,103,108,3,12,6,0,104,
		108,3,14,7,0,105,108,3,16,8,0,106,108,3,18,9,0,107,100,1,0,0,0,107,101,
		1,0,0,0,107,102,1,0,0,0,107,103,1,0,0,0,107,104,1,0,0,0,107,105,1,0,0,
		0,107,106,1,0,0,0,108,7,1,0,0,0,109,110,5,11,0,0,110,111,3,6,3,0,111,9,
		1,0,0,0,112,113,5,3,0,0,113,114,3,6,3,0,114,115,5,7,0,0,115,116,3,6,3,
		0,116,117,5,4,0,0,117,11,1,0,0,0,118,119,5,3,0,0,119,120,3,6,3,0,120,121,
		5,8,0,0,121,122,3,6,3,0,122,123,5,4,0,0,123,13,1,0,0,0,124,125,5,3,0,0,
		125,126,3,6,3,0,126,127,5,9,0,0,127,128,3,6,3,0,128,129,5,4,0,0,129,15,
		1,0,0,0,130,131,5,3,0,0,131,132,3,6,3,0,132,133,5,10,0,0,133,134,3,6,3,
		0,134,135,5,4,0,0,135,17,1,0,0,0,136,137,5,3,0,0,137,138,3,6,3,0,138,139,
		5,12,0,0,139,140,3,6,3,0,140,141,5,4,0,0,141,19,1,0,0,0,142,143,5,15,0,
		0,143,21,1,0,0,0,144,145,5,16,0,0,145,23,1,0,0,0,146,147,5,3,0,0,147,148,
		5,18,0,0,148,149,3,22,11,0,149,150,5,4,0,0,150,156,1,0,0,0,151,152,5,3,
		0,0,152,153,3,22,11,0,153,154,5,4,0,0,154,156,1,0,0,0,155,146,1,0,0,0,
		155,151,1,0,0,0,156,25,1,0,0,0,157,158,5,3,0,0,158,159,5,17,0,0,159,160,
		3,22,11,0,160,161,5,4,0,0,161,27,1,0,0,0,162,163,3,2,1,0,163,178,5,3,0,
		0,164,168,3,20,10,0,165,167,5,5,0,0,166,165,1,0,0,0,167,170,1,0,0,0,168,
		166,1,0,0,0,168,169,1,0,0,0,169,179,1,0,0,0,170,168,1,0,0,0,171,175,3,
		22,11,0,172,174,5,5,0,0,173,172,1,0,0,0,174,177,1,0,0,0,175,173,1,0,0,
		0,175,176,1,0,0,0,176,179,1,0,0,0,177,175,1,0,0,0,178,164,1,0,0,0,178,
		171,1,0,0,0,179,180,1,0,0,0,180,178,1,0,0,0,180,181,1,0,0,0,181,182,1,
		0,0,0,182,183,5,4,0,0,183,192,1,0,0,0,184,187,3,2,1,0,185,188,3,20,10,
		0,186,188,3,22,11,0,187,185,1,0,0,0,187,186,1,0,0,0,188,189,1,0,0,0,189,
		187,1,0,0,0,189,190,1,0,0,0,190,192,1,0,0,0,191,162,1,0,0,0,191,184,1,
		0,0,0,192,29,1,0,0,0,193,194,3,32,16,0,194,31,1,0,0,0,195,205,3,28,14,
		0,196,205,3,36,18,0,197,205,3,34,17,0,198,205,3,38,19,0,199,205,3,40,20,
		0,200,205,3,42,21,0,201,205,3,44,22,0,202,205,3,46,23,0,203,205,3,48,24,
		0,204,195,1,0,0,0,204,196,1,0,0,0,204,197,1,0,0,0,204,198,1,0,0,0,204,
		199,1,0,0,0,204,200,1,0,0,0,204,201,1,0,0,0,204,202,1,0,0,0,204,203,1,
		0,0,0,205,33,1,0,0,0,206,208,5,11,0,0,207,206,1,0,0,0,207,208,1,0,0,0,
		208,211,1,0,0,0,209,212,3,26,13,0,210,212,3,24,12,0,211,209,1,0,0,0,211,
		210,1,0,0,0,212,213,1,0,0,0,213,214,3,32,16,0,214,35,1,0,0,0,215,216,5,
		11,0,0,216,217,3,32,16,0,217,37,1,0,0,0,218,219,5,3,0,0,219,220,3,32,16,
		0,220,221,5,7,0,0,221,222,3,32,16,0,222,223,5,4,0,0,223,39,1,0,0,0,224,
		225,5,3,0,0,225,226,3,32,16,0,226,227,5,8,0,0,227,228,3,32,16,0,228,229,
		5,4,0,0,229,41,1,0,0,0,230,231,5,3,0,0,231,232,3,32,16,0,232,233,5,9,0,
		0,233,234,3,32,16,0,234,235,5,4,0,0,235,43,1,0,0,0,236,237,5,3,0,0,237,
		238,3,32,16,0,238,239,5,10,0,0,239,240,3,32,16,0,240,241,5,4,0,0,241,45,
		1,0,0,0,242,243,5,3,0,0,243,244,3,32,16,0,244,245,5,12,0,0,245,246,3,32,
		16,0,246,247,5,4,0,0,247,47,1,0,0,0,248,251,3,20,10,0,249,251,3,22,11,
		0,250,248,1,0,0,0,250,249,1,0,0,0,251,252,1,0,0,0,252,255,5,13,0,0,253,
		256,3,20,10,0,254,256,3,22,11,0,255,253,1,0,0,0,255,254,1,0,0,0,256,49,
		1,0,0,0,257,258,3,30,15,0,258,259,7,0,0,0,259,262,1,0,0,0,260,262,3,30,
		15,0,261,257,1,0,0,0,261,260,1,0,0,0,262,51,1,0,0,0,263,264,3,30,15,0,
		264,53,1,0,0,0,265,267,3,50,25,0,266,265,1,0,0,0,267,268,1,0,0,0,268,266,
		1,0,0,0,268,269,1,0,0,0,269,270,1,0,0,0,270,271,5,19,0,0,271,272,3,52,
		26,0,272,55,1,0,0,0,273,274,3,4,2,0,274,275,7,0,0,0,275,278,1,0,0,0,276,
		278,3,4,2,0,277,273,1,0,0,0,277,276,1,0,0,0,278,57,1,0,0,0,279,280,3,4,
		2,0,280,59,1,0,0,0,281,283,3,56,28,0,282,281,1,0,0,0,283,284,1,0,0,0,284,
		282,1,0,0,0,284,285,1,0,0,0,285,286,1,0,0,0,286,287,5,19,0,0,287,288,3,
		58,29,0,288,61,1,0,0,0,289,291,3,50,25,0,290,289,1,0,0,0,291,292,1,0,0,
		0,292,290,1,0,0,0,292,293,1,0,0,0,293,294,1,0,0,0,294,295,5,20,0,0,295,
		296,3,30,15,0,296,63,1,0,0,0,297,299,3,56,28,0,298,297,1,0,0,0,299,300,
		1,0,0,0,300,298,1,0,0,0,300,301,1,0,0,0,301,302,1,0,0,0,302,303,5,20,0,
		0,303,304,3,4,2,0,304,65,1,0,0,0,21,94,107,155,168,175,178,180,187,189,
		191,204,207,211,250,255,261,268,277,284,292,300
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
